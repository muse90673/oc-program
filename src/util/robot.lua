---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ThinkPad E475.
--- DateTime: 2019/4/21 14:45
---

local thread = require("thread")
local event = require("event")
local comp = require("component")
local sides = require("sides")

local config = require("config.config")
local map = require("obj.Map")
local pathing = require("util.AstarPathing")
pathing.map = map


local status = ""
local listen_id
--- size:
---   ox,sx
---   oy,sy
---   oz,sz
--- block:
---   x,y,z
--- curr_work:
---   dx,dy,dz
--- curr_pos:
---   x,y,z
local work_status = {}
work_status.size={}
work_status.size.ox=config.work_area_ox
work_status.size.oy=config.work_area_oy
work_status.size.oz=config.work_area_oz
work_status.size.sx=config.work_area_sx
work_status.size.sy=config.work_area_sy
work_status.size.sz=config.work_area_sz

work_status.block={}
work_status.curr_work={}
work_status.curr_pos={}

pathing.work_area=work_status.size
pathing.public_area={}
pathing.public_area.ox=config.work_area_ox
pathing.public_area.oy=config.work_area_oy
pathing.public_area.oz=config.init_z+1
pathing.public_area.sx=config.work_area_sx
pathing.public_area.sy=config.work_area_sy
pathing.public_area.sz=config.public_sz
--- 记录临时障碍物
local temp_block_list = {}


function work()
    local has_next,x,y,z = getNextBlock()
    if has_next then
        local dir,binfo = move(x,y,z)
        if dir then
            if isExcavable(dir) then
                if binfo then
                    comp.robot.swing(dir)
                end
                map:setPosInfo(x,y,z,0)
            end
        end
    end
end

---
--- 机器人移动
--- 参数dx,dy,dz: 终点坐标
--- 返回值：sides 返回front, top, down, 如果起点终点重合，返回nil;
---        block_info 如果从倒数第二个节点移动到终点前被阻挡，返回方块信息，否则nil
---
function move(dx,dy,dz)
    local x,y,z = getPos()
    if x==dx and y==dy and z==dz then
        return nil
    end
    local dir = comp.navigation.getFacing()
    if not map:setPosInfo(x,y,z,0) then
        return nil
    end
    local paths = pathing.getPath(dx,dy,dz,x,y,z,dir,true)
    local dir_map = {[2]=1,[3]=3,[4]=2,[5]=0}
    if paths then
        local cdir = dir_map[dir]
        for i=2,#paths do
            local ddir
            local binfo
            local curr_sides
            if paths[i].z-paths[i-1].z > 0 then
                curr_sides = sides.top
            elseif paths[i].z-paths[i-1].z < 0 then
                curr_sides = sides.down
            elseif paths[i].x-paths[i-1].x > 0 then
                ddir = 0
            elseif paths[i].x-paths[i-1].x < 0 then
                ddir = 2
            elseif paths[i].y-paths[i-1].y > 0 then
                ddir = 3
            elseif paths[i].y-paths[i-1].y < 0 then
                ddir = 1
            end
            if ddir then
                local r1 = math.abs(ddir-cdir)
                local r2 = 4-r1
                local min = math.min(r1,r2)
                local clockwish = false
                if (cdir-min)%4==ddir then
                    clockwish = true
                end
                for j=1, min do
                    comp.robot.turn(clockwish)
                end
                cdir = ddir
                curr_sides = sides.front
            end
            _,binfo = comp.robot.move(curr_sides)
            if not binfo then
                setPos(paths[i].x,paths[i].y,paths[i].z)
            end
            if i==#paths then
                return curr_sides,binfo
            end
            -- 如果被挡路，尝试挖掉方块,失败则绕路
            if binfo then
                if binfo ~= "entity" and isExcavable(curr_sides) then
                    comp.robot.swing(curr_sides)
                    map:setPosInfo(paths[i].x,paths[i].y,paths[i].z,0)
                    comp.robot.move(curr_sides)
                else
                    -- 绕路
                    setTempBlock(paths[i].x,paths[i].y,paths[i].z)
                    curr_sides = move(dx,dy,dz)
                    clearTempBlock()
                    return curr_sides,binfo
                end
            end
        end
    end
    return nil
end

function moveToScan()

end

function scan()
    -- 扫描以自身为中心范围内的地形
    local x,y,z = getLocation()
    print(x,y,z)
    local scanx,scany,scanz = x-32, y-32, z-32
    scanx = scanx-(scanx%-map.girdX)
    scany = scany-(scany%-map.girdY)
    scanz = scanz-(scanz%-map.girdZ)
    -- 向上溢出的扫描高度，防止机器人无法从原点抵达工作区域
    local ovfZ = 5
    for iy=scany, y+32-map.girdY, map.girdY do
        for ix=scanx, x+32-map.girdX, map.girdX do
            local flag = false
            if math.abs(ix-work_status.size.ox+(map.girdX-work_status.size.sx)/2) < ((map.girdX+work_status.size.sx)/2) and
                    math.abs(iy-work_status.size.oy+(map.girdY-work_status.size.sy)/2) < ((map.girdY+work_status.size.sy)/2) then
                for iz=scanz, z+32-map.girdZ, map.girdZ do
                    local cx = ix/map.girdX
                    local cy = iy/map.girdY
                    local cz = iz/map.girdZ
                    if not map:hasChunk(cx,cy,cz) then
                        flag = true
                        break
                    end
                    --print("ignore:"..tostring(ix)..","..tostring(iy)..","..tostring(iz))
                end
            end
            if flag then
                local datas = {}
                for sy=iy,iy+map.girdY-1 do
                    for sx=ix,ix+map.girdX-1 do
                        local data = comp.geolyzer.scan(sx-x,sy-y,false)
                        --print("scan:x="..tostring(sx-x)..",y="..tostring(sy-y))
                        table.insert(datas,data)
                    end
                end
                for sz=scanz, z+32-map.girdZ, map.girdZ do
                    local cx = ix/map.girdX
                    local cy = iy/map.girdY
                    local cz = sz/map.girdZ
                    if math.abs(sz-work_status.size.oz+(map.girdZ-(work_status.size.sz +ovfZ))/2) < ((map.girdZ+work_status.size.sz +ovfZ)/2) and
                            not map:hasChunk(cx,cy,cz) then
                        local chunk = {}
                        local index = 0
                        for jz=sz, sz+map.girdZ-1 do
                            for j=1, #datas do
                                local info = datas[j][jz-z+33]
                                if info ~= 0 then
                                    chunk[index] = 1
                                else
                                    chunk[index] = 0
                                end
                                index=index+1
                            end
                            print("save:z="..tostring(jz-z+33))
                        end
                        map:saveChunk(cx,cy,cz,chunk)
                    end
                end
            end
        end
    end
end

function back()

end

---
--- 获取下一个可挖掘的方块
--- 返回值：x,y,z 方块坐标
---
function getNextBlock()
    local block = work_status.block
    local wsize = work_status.size
    local curr_work = work_status.curr_work
    local flag = true
    if not block.x then
        block.x = wsize.ox
        block.y = wsize.oy
        block.z = -1
        curr_work.dx = 1
        curr_work.dy = 1
        curr_work.dz = -1
        curr_work.cx, curr_work.cy, curr_work.cz = 1,1,1
        flag = false
    end
    -- 搜索下一个可挖掘方块
    while flag do
        if curr_work.cz == wsize.sz+1 and curr_work.cy == wsize.sy and curr_work.cx == wsize.sx then
            -- 工作区域内所有方块被挖完
            break
        elseif curr_work.cy == wsize.sy and curr_work.cx == wsize.sx then
            block.z = block.z + curr_work.dz
            curr_work.cz = curr_work.cz + 1
            curr_work.dy = curr_work.dy*-1
            curr_work.dx = curr_work.dx*-1
            curr_work.cy = 1
            curr_work.cx = 1
        elseif curr_work.cx == wsize.sx then
            block.y = block.y + curr_work.dy
            curr_work.cy = curr_work.cy + 1
            curr_work.dx = curr_work.dx*-1
            curr_work.cx = 1
        else
            block.x = block.x + curr_work.dx
            curr_work.cx = curr_work.cx + 1
        end
        local bi = map:getPosInfo(block.x,block.y,block.z)
        if bi and bi == 1 then
            return true, block.x, block.y, block.z
        else
            -- error
            break
        end
    end
    return false
end

function getLocation()
    local wp = comp.navigation.findWaypoints(512)
    for k,v in pairs(wp) do
        if type(v)=="table" and v["label"] == "origin" then
            local x = -v["position"][1]
            local z = -v["position"][2]
            local y = -v["position"][3]
            return x,y,z
        end
    end
    print("get position faild! waypoint \"origin\" not found!")
    return nil
end
function getPos()
    if work_status.curr_pos.x then
        local x,y,z = getLocation()
        setPos(x,y,z)
        return x,y,z
    end
    return work_status.curr_pos.x, work_status.curr_pos.y, work_status.curr_pos.z
end
function setPos(x,y,z)
    work_status.curr_pos.x = x
    work_status.curr_pos.y = y
    work_status.curr_pos.z = z
end
---
--- 探测方块能否被挖掘
--- dir:sides {front, top, down}
--- 返回值：boolean true:可挖掘 false:不可挖掘
---
function isExcavable(dir)
    local binfo = comp.geolyzer.analyze(dir)
    if binfo then
        -- 忽略指定的方块{基岩、oc方块}
        local hardness = binfo["hardness"]
        local harvest_tool = binfo["harvestTool"]
        if hardness<10 then
            if harvest_tool then
                if harvest_tool == "pickaxe" or harvest_tool == "shovel" then
                    return true
                end
            else
                return true
            end
        end
    end
    return false
end

function setTempBlock(x,y,z)
    table.insert(temp_block_list, {["x"]=x, ["y"]=y, ["z"]=z})
    map:setPosInfo(x,y,z,1)
end

function clearTempBlock()
    for k,v in pairs() do
        map:setPosInfo(x,y,z,0)
    end
    temp_block_list = {}
end

function receiveMessage(a,b,c,d,e,order)
    status = order
end

function checkStatus()
    
end

function run()
    --listen_id = event.listen("modem_message",receiveMessage)
    setPos(x,y,z)
    status = "work"
    while true do
        if status=="work" then
            work()
        elseif status == "scan" then
            scan()
        elseif status == "back" then
            back()
        end
        os.sleep(0)
    end
    --event.cancel(listen_id)
end