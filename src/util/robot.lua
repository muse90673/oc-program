---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ThinkPad E475.
--- DateTime: 2019/4/21 14:45
---

thread = require("thread")
event = require("event")
comp = require("component")
sides = require("sides")

local config = require("config.config")
local status = ""

--- size:
---   ox,lx
---   oy,ly
---   oz,lz
--- block:
---   x,y,z
--- curr_work:
---   dx,dy,dz
--- curr_pos:
---   x,y,z
local workStatus = {}
workStatus.size={}
workStatus.size.ox=config.work_area_ox
workStatus.size.oy=config.work_area_oy
workStatus.size.oz=config.work_area_oz
workStatus.size.lx=config.work_area_sx
workStatus.size.ly=config.work_area_sy
workStatus.size.lz=config.work_area_sz

workStatus.block={}
workStatus.curr_work={}

--- 记录临时障碍物
local temp_block_list = {}

local map = require("obj.Map")
local listenID
local pathing = require("util.AstarPathing")

function work()
    local has_next,x,y,z = getNextBlock()
    if has_next then
        local dir = move(x,y,z)
        if dir then
            if isExcavable(dir) then
                comp.robot.swing(dir)
            end
        end
    end
end

---
--- 机器人移动
--- 参数dx,dy,dz: 终点坐标
--- 返回值：sides {front, top, down}
---        如果起点终点重合，返回nil
---
function move(dx,dy,dz)

    local flag,side = pcall(_move,dx,dy,dz)
    if flag then
        return side
    else
        if string.find(side,"request scan") then
            -- 扫描地形
            --local pos
            --local oz = workStatus.block.z+1
            --local sx,sy =
            --for i=1,31 do
            --    map:getPosInfo()
            --end
            print(side)
        else
            print(side)
        end
        return nil
    end
end

function _move(dx,dy,dz)
    local x,y,z = getLocation()
    if x==dx and y==dy and z==dz then
        return nil
    end
    local dir = comp.navigation.getFacing()
    if not map:setPosInfo(x,y,z,0) then
        return nil
    end
    local paths = pathing.getPath(map,dx,dy,dz,x,y,z,dir,true)
    local dir_map = {[2]=1,[3]=3,[4]=2,[5]=0}
    if paths then
        local cdir = dir_map[dir]
        for i=2,#paths do
            local ddir
            local binfo
            local curr_sides
            if paths[i].z-paths[i-1].z > 0 then
                curr_sides = sides.top
            elseif paths[i].z-paths[i-1].z < 0 then
                curr_sides = sides.down
            elseif paths[i].x-paths[i-1].x > 0 then
                ddir = 0
            elseif paths[i].x-paths[i-1].x < 0 then
                ddir = 2
            elseif paths[i].y-paths[i-1].y > 0 then
                ddir = 3
            elseif paths[i].y-paths[i-1].y < 0 then
                ddir = 1
            end
            if ddir then
                local r1 = math.abs(ddir-cdir)
                local r2 = 4-r1
                local min = math.min(r1,r2)
                local clockwish = false
                if (cdir-min)%4==ddir then
                    clockwish = true
                end
                for j=1, min do
                    comp.robot.turn(clockwish)
                end
                cdir = ddir
                curr_sides = sides.front
            end
            _,binfo = comp.robot.move(curr_sides)
            if i==#paths then
                return curr_sides
            end
            -- 如果被挡路，尝试挖掉方块,失败则绕路
            if binfo then
                if binfo ~= "entity" and isExcavable(curr_sides) then
                    comp.robot.swing(curr_sides)
                    comp.robot.move(curr_sides)
                else
                    -- 绕路
                    setTempBlock(paths[i].x,paths[i].y,paths[i].z)
                    curr_sides = move(dx,dy,dz)
                    clearTempBlock()
                    return curr_sides
                end
            end
        end
    end
    return nil
end

function moveToScan()
    
end

function scan()
    -- 扫描以自身为中心范围内的地形
    local x,y,z = getLocation()
    print(x,y,z)
    local scanx,scany,scanz = x-32, y-32, z-32
    scanx = scanx-(scanx%-map.girdX)
    scany = scany-(scany%-map.girdY)
    scanz = scanz-(scanz%-map.girdZ)
    -- 向上溢出的扫描高度，防止机器人无法从原点抵达工作区域
    local ovfZ = 5
    for iy=scany, y+32-map.girdY, map.girdY do
        for ix=scanx, x+32-map.girdX, map.girdX do
            local flag = false
            if math.abs(ix-workStatus.size.ox+(map.girdX-workStatus.size.lx)/2) < ((map.girdX+workStatus.size.lx)/2) and
                    math.abs(iy-workStatus.size.oy+(map.girdY-workStatus.size.ly)/2) < ((map.girdY+workStatus.size.ly)/2) then
                for iz=scanz, z+32-map.girdZ, map.girdZ do
                    local cx = ix/map.girdX
                    local cy = iy/map.girdY
                    local cz = iz/map.girdZ
                    if not map:hasChunk(cx,cy,cz) then
                        flag = true
                        break
                    end
                    --print("ignore:"..tostring(ix)..","..tostring(iy)..","..tostring(iz))
                end
            end
            if flag then
                local datas = {}
                for sy=iy,iy+map.girdY-1 do
                    for sx=ix,ix+map.girdX-1 do
                        local data = comp.geolyzer.scan(sx-x,sy-y,false)
                        --print("scan:x="..tostring(sx-x)..",y="..tostring(sy-y))
                        table.insert(datas,data)
                    end
                end
                for sz=scanz, z+32-map.girdZ, map.girdZ do
                    local cx = ix/map.girdX
                    local cy = iy/map.girdY
                    local cz = sz/map.girdZ
                    if math.abs(sz-workStatus.size.oz+(map.girdZ-(workStatus.size.lz+ovfZ))/2) < ((map.girdZ+workStatus.size.lz+ovfZ)/2) and
                            not map:hasChunk(cx,cy,cz) then
                        local chunk = {}
                        local index = 0
                        for jz=sz, sz+map.girdZ-1 do
                            for j=1, #datas do
                                local info = datas[j][jz-z+33]
                                if info ~= 0 then
                                    chunk[index] = 1
                                else
                                    chunk[index] = 0
                                end
                                index=index+1
                            end
                            print("save:z="..tostring(jz-z+33))
                        end
                        map:saveChunk(cx,cy,cz,chunk)
                    end
                end
            end
        end
    end
end

function back()

end

---
--- 获取下一个可挖掘的方块
--- 返回值：x,y,z 方块坐标
---
function getNextBlock()
    local block = workStatus.block
    local wsize = workStatus.size
    local curr_work = workStatus.curr_work
    local flag = true
    if not block.x then
        block.x = wsize.ox
        block.y = wsize.oy
        block.z = 0
        curr_work.dx = 1
        curr_work.dy = 1
        curr_work.dz = -1
        curr_work.cx, curr_work.cy, curr_work.cz = 1,1,1
        flag = false
    end
    -- 搜索下一个可挖掘方块
    while flag do
        local bi = map:getPosInfo(block.x,block.y,block.z)
        if bi then
            if curr_work.cz == wsize.lz+1 and curr_work.cy == wsize.ly and curr_work.cx == wsize.lx then
                -- 工作区域内所有方块被挖完
                return false
            elseif curr_work.cy == wsize.ly and curr_work.cx == wsize.lx then
                block.z = block.z + curr_work.dz
                curr_work.cz = curr_work.cz + 1
                curr_work.dy = curr_work.dy*-1
                curr_work.cy = 1
                curr_work.cx = 1
            elseif curr_work.cx == wsize.lx then
                block.y = block.y + curr_work.dy
                curr_work.cy = curr_work.cy + 1
                curr_work.dx = curr_work.dx*-1
                curr_work.cx = 1
            else
                block.x = block.x + curr_work.dx
                curr_work.cx = curr_work.cx + 1
            end
            if bi == 1 then
                break
            end
        else
            -- error
            break
        end
    end
    return true, block.x, block.y, block.z
end

function getLocation()
    local wp = comp.navigation.findWaypoints(512)
    for k,v in pairs(wp) do
        if type(v)=="table" and v["label"] == "origin" then
            local x = -v["position"][1]
            local z = -v["position"][2]
            local y = -v["position"][3]
            return x,y,z
        end
    end
    print("get position faild! waypoint \"origin\" not found!")
    return nil
end

---
--- 探测方块能否被挖掘
--- dir:sides {front, top, down}
--- 返回值：boolean true:可挖掘 false:不可挖掘
---
function isExcavable(dir)
    local binfo = comp.geolyzer.analyze(dir)
    if binfo then
        local hardness = binfo["hardness"]
        local harvest_tool = binfo["harvestTool"]
        if hardness<10 then
            if harvest_tool then
                if harvest_tool == "pickaxe" or harvest_tool == "shovel" then
                    return true
                end
            else
                return true
            end
        end
    end
    return false
end

function setTempBlock(x,y,z)
    table.insert(temp_block_list, {["x"]=x, ["y"]=y, ["z"]=z})
    map:setPosInfo(x,y,z,1)
end

function clearTempBlock()
    for k,v in pairs() do
        map:setPosInfo(x,y,z,0)
    end
    temp_block_list = {}
end

function receiveMessage(a,b,c,d,e,order)
    status = order
end

function checkStatus()
    
end

function run()
    listen_id = event.listen("modem_message",receiveMessage)
    status = "work"
    while true do
        if status=="work" then
            work()
        elseif status == "scan" then
            scan()
        elseif status == "back" then
            back()
        end
        os.sleep(0)
    end
    event.cancel(listen_id)
end