---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ThinkPad E475.
--- DateTime: 2019/4/21 14:45
---

thread = require("thread")
event = require("event")
comp = require("component")
sides = require("sides")

local status = ""
--- size:
--- ox,lx
--- oy,ly
--- oz,lz
--- block:
--- x,y,z
--- curr_work:
--- dx,dy,dz
local workStatus = {}
workStatus.size={}
workStatus.size.ox=-5
workStatus.size.oy=-5
workStatus.size.oz=-5
workStatus.size.lx=10
workStatus.size.ly=10
workStatus.size.lz=5

workStatus.block={}
workStatus.curr_work={}

local map = require("obj.Map")
local listenID
local pathing = require("util.AstarPathing")

function work()
    local block = workStatus.block
    local wsize = workStatus.size
    local curr_work = workStatus.curr_work

    if block then
        block.x = wsize.ox
        block.y = wsize.oy
        block.z = wsize.oz
        curr_work.dx = 1
        curr_work.dy = 1
        curr_work.dz = -1
        curr_work.cx, curr_work.cy, curr_work.cz = 0
    end
    --local is_continue = true
    -- 搜索下一个可挖掘方块
    while true do
        local bi = map:getPosInfo(block.x,block.y,block.z)
        if bi then
            if bi == 1 then
                break
            end
            if curr_work.cz == wsize.lz then
                curr_work.dz = curr_work.dz*-1
                -- 工作区域内所有方块被挖完
            elseif curr_work.cy == wsize.ly then
                block.z = block.z + curr_work.dz
                curr_work.cz = curr_work.cz + 1
                curr_work.dy = curr_work.dy*-1
                curr_work.cy = 0
            elseif curr_work.cx == wsize.lx then
                block.y = block.y + curr_work.dy
                curr_work.cy = curr_work.cy + 1
                curr_work.dx = curr_work.dx*-1
                curr_work.cx = 0
            else
                block.x = block.x + curr_work.dx
                curr_work.cx = curr_work.cx + 1
            end

        else
            -- error
            break
        end

    end

    local dirs = move(block.x,block.y,block.z)
    if dirs=="front" then
        comp.robot.swing(sides.front)
    elseif dirs=="top" then
        comp.robot.swing(sides.top)
    elseif dirs=="down" then
        comp.robot.swing(sides.down)
    end
end

function nextBlock()

end

function move(dx,dy,dz)
    local x,y,z = getLocation()
    local dir = comp.navigation.getFacing()
    map:setPosInfo(x,y,z,0)
    print("posinfo=", map:getPosInfo(x,y,z))
    local paths = pathing.getPath(map,dx,dy,dz,x,y,z,dir,true)
    print("paths=",paths)
    local dir_map = {[2]=1,[3]=3,[4]=2,[5]=0}
    if paths then
        local dst_block = paths[#paths]
        local cx,cy,cz = x,y,z
        local cdir = dir_map[dir]
        for i=2,#paths do
            local ddir
            if paths[i].z-paths[i-1].z > 0 then
                if i==#paths then
                    return "top"
                end
                comp.robot.move(sides.top)
            elseif paths[i].z-paths[i-1].z < 0 then
                if i==#paths then
                    return "down"
                end
                comp.robot.move(sides.down)
            elseif paths[i].x-paths[i-1].x > 0 then
                ddir = 0
            elseif paths[i].x-paths[i-1].x < 0 then
                ddir = 2
            elseif paths[i].y-paths[i-1].y > 0 then
                ddir = 1
            elseif paths[i].y-paths[i-1].y < 0 then
                ddir = 3
            end
            if ddir and cdir~=ddir then
                local r1 = ddir-cdir
                local r2 = r1%4
                local minr
                if math.abs(r1)<math.abs(r2) then
                    minr = r1
                else
                    minr = r2
                end
                for j=1, math.abs(minr) do
                    if minr>0 then
                        comp.robot.turn(false)
                    else
                        comp.robot.turn(true)
                    end
                end
                cdir = ddir
                --TODO 探测前面的方块
                if i~=#paths then
                    comp.robot.move(sides.front)
                end
            end
        end
    end
    return "front"
end

function scan()
    -- 扫描以自身为中心范围内的地形
    local x,y,z = getLocation()
    print(x,y,z)
    local scanx,scany,scanz = x-32, y-32, z-32
    scanx = scanx-(scanx%-map.girdX)
    scany = scany-(scany%-map.girdY)
    scanz = scanz-(scanz%-map.girdZ)
    -- 向上溢出的扫描高度，防止机器人无法从原点抵达工作区域
    local ovfZ = 5
    for iy=scany, y+32-map.girdY, map.girdY do
        for ix=scanx, x+32-map.girdX, map.girdX do
            local flag = false
            if math.abs(ix-workStatus.size.ox+(map.girdX-workStatus.size.lx)/2) < ((map.girdX+workStatus.size.lx)/2) and
                    math.abs(iy-workStatus.size.oy+(map.girdY-workStatus.size.ly)/2) < ((map.girdY+workStatus.size.ly)/2) then
                for iz=scanz, z+32-map.girdZ, map.girdZ do
                    local cx = ix/map.girdX
                    local cy = iy/map.girdY
                    local cz = iz/map.girdZ
                    if not map:hasChunk(cx,cy,cz) then
                        flag = true
                        break
                    end
                    --print("ignore:"..tostring(ix)..","..tostring(iy)..","..tostring(iz))
                end
            end
            if flag then
                local datas = {}
                for sy=iy,iy+map.girdY-1 do
                    for sx=ix,ix+map.girdX-1 do
                        local data = comp.geolyzer.scan(sx-x,sy-y,false)
                        --print("scan:x="..tostring(sx-x)..",y="..tostring(sy-y))
                        table.insert(datas,data)
                    end
                end
                for sz=scanz, z+32-map.girdZ, map.girdZ do
                    local cx = ix/map.girdX
                    local cy = iy/map.girdY
                    local cz = sz/map.girdZ
                    if math.abs(sz-workStatus.size.oz+(map.girdZ-(workStatus.size.lz+ovfZ))/2) < ((map.girdZ+workStatus.size.lz+ovfZ)/2) and
                            not map:hasChunk(cx,cy,cz) then
                        local chunk = {}
                        local index = 0
                        for jz=sz, sz+map.girdZ-1 do
                            for j=1, #datas do
                                local info = datas[j][jz-z+33]
                                if info ~= 0 then
                                    chunk[index] = 1
                                else
                                    chunk[index] = 0
                                end
                                index=index+1
                            end
                            print("save:z="..tostring(jz-z+33))
                        end
                        map:saveChunk(cx,cy,cz,chunk)
                    end
                end
            end
        end
    end
end

function back()

end

function getLocation()
    local wp = comp.navigation.findWaypoints(512)
    for k,v in pairs(wp) do
        if type(v)=="table" and v["label"] == "origin" then
            local x = -v["position"][1]
            local z = -v["position"][2]
            local y = -v["position"][3]
            return x,y,z
        end
    end
    print("get position faild! waypoint \"origin\" not found!")
    return nil
end

function receiveMessage(a,b,c,d,e,order)
    status = order
end

function printStatus()

end

function run()
    --listenID = event.listen("modem_message",receiveMessage)

    while true do
        if status=="work" then
            work()
        elseif status == "scan" then
            scan()
        elseif status == "back" then
            back()
        end
        os.sleep(0)
    end
    event.cancel(listenID)
end