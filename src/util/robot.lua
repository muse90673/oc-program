---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ThinkPad E475.
--- DateTime: 2019/4/21 14:45
---

thread = require("thread")
event = require("event")
comp = require("component")
sides = require("sides")

local status = ""

--- size:
--- ox,lx
--- oy,ly
--- oz,lz
--- block:
--- x,y,z
--- curr_work:
--- dx,dy,dz
--- curr_pos:
--- x,y,z
local workStatus = {}
workStatus.size={}
workStatus.size.ox=-5
workStatus.size.oy=-5
workStatus.size.oz=-5
workStatus.size.lx=10
workStatus.size.ly=10
workStatus.size.lz=5

workStatus.block={}
workStatus.curr_work={}

local map = require("obj.Map")
local listenID
local pathing = require("util.AstarPathing")

function work()
    local block = workStatus.block
    local wsize = workStatus.size
    local curr_work = workStatus.curr_work

    if block then
        block.x = wsize.ox
        block.y = wsize.oy
        block.z = wsize.oz
        curr_work.dx = 1
        curr_work.dy = 1
        curr_work.dz = -1
        curr_work.cx, curr_work.cy, curr_work.cz = 0,0,0
    end
    --local is_continue = true
    -- 搜索下一个可挖掘方块
    while true do
        local bi = map:getPosInfo(block.x,block.y,block.z)
        if bi then
            if bi == 1 then
                break
            end
            if curr_work.cz == wsize.lz-1 then
                curr_work.dz = curr_work.dz*-1
                -- 工作区域内所有方块被挖完
            elseif curr_work.cy == wsize.ly-1 then
                block.z = block.z + curr_work.dz
                curr_work.cz = curr_work.cz + 1
                curr_work.dy = curr_work.dy*-1
                curr_work.cy = 0
            elseif curr_work.cx == wsize.lx-1 then
                block.y = block.y + curr_work.dy
                curr_work.cy = curr_work.cy + 1
                curr_work.dx = curr_work.dx*-1
                curr_work.cx = 0
            else
                block.x = block.x + curr_work.dx
                curr_work.cx = curr_work.cx + 1
            end

        else
            -- error
            break
        end

    end

    local dirs = move(block.x,block.y,block.z)
    if dirs then
        -- 判断机器人现在坐标是否和终点重合，如果重合则获取下一个可挖掘方块
        -- 探测前面的方块
        if isExcavable(dirs) then
            comp.robot.swing(dirs)
        end
    end
end

---
--- 机器人移动
--- 参数dx,dy,dz: 终点坐标
--- 返回值：sides {front, top, down}
---        如果起点终点重合，返回nil
---
function move(dx,dy,dz)
    local x,y,z = getLocation()
    if x==dx and y==dy and z==dz then
        local dir = comp.navigation.getFacing()
        if map:setPosInfo(x,y,z,0) then
            return nil
        end
        local paths = pathing.getPath(map,dx,dy,dz,x,y,z,dir,true)
        local dir_map = {[2]=1,[3]=3,[4]=2,[5]=0}
        if paths then
            local cdir = dir_map[dir]
            for i=2,#paths do
                local ddir
                local binfo
                local curr_sides
                if paths[i].z-paths[i-1].z > 0 then
                    curr_sides = sides.top
                    _,binfo = comp.robot.move(curr_sides)
                elseif paths[i].z-paths[i-1].z < 0 then
                    curr_sides = sides.down
                    _,binfo = comp.robot.move(curr_sides)
                elseif paths[i].x-paths[i-1].x > 0 then
                    ddir = 0
                elseif paths[i].x-paths[i-1].x < 0 then
                    ddir = 2
                elseif paths[i].y-paths[i-1].y > 0 then
                    ddir = 3
                elseif paths[i].y-paths[i-1].y < 0 then
                    ddir = 1
                end
                if ddir then
                    local r1 = math.abs(ddir-cdir)
                    local r2 = 4-r1
                    local min = math.min(r1,r2)
                    local clockwish = false
                    if (cdir-min)%4==ddir then
                        clockwish = true
                    end
                    for j=1, min do
                        comp.robot.turn(clockwish)
                    end
                    cdir = ddir
                    curr_sides = sides.front
                    _,binfo = comp.robot.move(curr_sides)
                end
                if i==#paths then
                    return curr_sides
                end
                -- 如果被挡路，尝试挖掉方块,失败则绕路
                if binfo then
                    if isExcavable(binfo) then
                        comp.robot.swing(curr_sides)
                    end
                end
            end
        end
    end
    return nil
end

function scan()
    -- 扫描以自身为中心范围内的地形
    local x,y,z = getLocation()
    print(x,y,z)
    local scanx,scany,scanz = x-32, y-32, z-32
    scanx = scanx-(scanx%-map.girdX)
    scany = scany-(scany%-map.girdY)
    scanz = scanz-(scanz%-map.girdZ)
    -- 向上溢出的扫描高度，防止机器人无法从原点抵达工作区域
    local ovfZ = 5
    for iy=scany, y+32-map.girdY, map.girdY do
        for ix=scanx, x+32-map.girdX, map.girdX do
            local flag = false
            if math.abs(ix-workStatus.size.ox+(map.girdX-workStatus.size.lx)/2) < ((map.girdX+workStatus.size.lx)/2) and
                    math.abs(iy-workStatus.size.oy+(map.girdY-workStatus.size.ly)/2) < ((map.girdY+workStatus.size.ly)/2) then
                for iz=scanz, z+32-map.girdZ, map.girdZ do
                    local cx = ix/map.girdX
                    local cy = iy/map.girdY
                    local cz = iz/map.girdZ
                    if not map:hasChunk(cx,cy,cz) then
                        flag = true
                        break
                    end
                    --print("ignore:"..tostring(ix)..","..tostring(iy)..","..tostring(iz))
                end
            end
            if flag then
                local datas = {}
                for sy=iy,iy+map.girdY-1 do
                    for sx=ix,ix+map.girdX-1 do
                        local data = comp.geolyzer.scan(sx-x,sy-y,false)
                        --print("scan:x="..tostring(sx-x)..",y="..tostring(sy-y))
                        table.insert(datas,data)
                    end
                end
                for sz=scanz, z+32-map.girdZ, map.girdZ do
                    local cx = ix/map.girdX
                    local cy = iy/map.girdY
                    local cz = sz/map.girdZ
                    if math.abs(sz-workStatus.size.oz+(map.girdZ-(workStatus.size.lz+ovfZ))/2) < ((map.girdZ+workStatus.size.lz+ovfZ)/2) and
                            not map:hasChunk(cx,cy,cz) then
                        local chunk = {}
                        local index = 0
                        for jz=sz, sz+map.girdZ-1 do
                            for j=1, #datas do
                                local info = datas[j][jz-z+33]
                                if info ~= 0 then
                                    chunk[index] = 1
                                else
                                    chunk[index] = 0
                                end
                                index=index+1
                            end
                            print("save:z="..tostring(jz-z+33))
                        end
                        map:saveChunk(cx,cy,cz,chunk)
                    end
                end
            end
        end
    end
end

function back()

end

function getLocation()
    local wp = comp.navigation.findWaypoints(512)
    for k,v in pairs(wp) do
        if type(v)=="table" and v["label"] == "origin" then
            local x = -v["position"][1]
            local z = -v["position"][2]
            local y = -v["position"][3]
            return x,y,z
        end
    end
    print("get position faild! waypoint \"origin\" not found!")
    return nil
end

---
--- 探测方块能否被挖掘
--- dir:sides {front, top, down}
--- 返回值：boolean true:可挖掘 false:不可挖掘
---
function isExcavable(dir)
    local binfo = comp.geolyzer.analyze(dir)
    if binfo then
        local hardness = binfo["hardness"]
        local harvest_tool = binfo["harvestTool"]
        if hardness<10 then
            if harvest_tool then
                if harvest_tool == "shovel" or harvest_tool == "shovel" then
                    return true
                end
            else
                return true
            end
        end
    end
    return false
end

function receiveMessage(a,b,c,d,e,order)
    status = order
end

function printStatus()

end

function run()
    listen_id = event.listen("modem_message",receiveMessage)
    status = "work"
    while true do
        if status=="work" then
            work()
        elseif status == "scan" then
            scan()
        elseif status == "back" then
            back()
        end
        os.sleep(0)
    end
    event.cancel(listen_id)
end