---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ThinkPad E475.
--- DateTime: 2019/4/15 11:15
---
package.path = "obj\\?.lua;util\\?.lua"..package.path

OpenList = require("obj.OpenList")
CloseList = require("obj.CloseList")
PathNode = require("obj.PathNode")


-- 地图数据
-- 0:可通行
-- 1:不可通行(障碍物)
-- 2:路径点

--mapGird = {[0]=0,0,0,0,0,0,0,0,
--           0,0,1,1,1,1,0,0,
--           0,0,0,0,0,1,0,0,
--           0,0,1,0,0,1,0,0,
--           0,0,0,0,0,1,0,0,
--           0,0,0,1,1,1,0,0,
--           0,0,0,0,0,0,0,0,
--           0,0,0,0,0,0,0,0,}

mapGird = {[0]=0,0,0,0,0,0,0,0,
           0,0,0,0,0,1,0,1,
           0,0,0,1,0,1,0,0,
           0,0,0,1,0,1,0,0,
           0,0,0,1,0,1,0,0,
           0,0,0,1,0,1,0,0,
           0,0,0,0,0,0,0,0,
           0,0,0,0,0,0,0,0,}

--mapGird = {[0]=0,0,0,0,0,0,0,0,
--           0,0,0,0,0,0,0,0,
--           0,0,0,0,0,0,0,0,
--           0,0,0,0,0,0,0,0,
--           0,0,0,0,0,0,0,0,
--           0,0,0,0,0,0,0,0,
--           0,0,0,0,0,0,0,0,
--           0,0,0,0,0,0,0,0,}

girdX = 8 -- 地图x轴大小
girdY = #mapGird/girdX -- 地图y轴大小
openList = OpenList:new()
closeList = CloseList:new()

--获取最短路径
-- ox,oy:起点坐标
-- dx,dy:终点坐标
function getPath(ox,oy,dx,dy)
    local ind = 0
    local originNode = PathNode:new(ox,oy,0,calcH(ox,oy,dx,dy))
    openList:add(originNode)
    while true do
        local minFNote = openList:getMinF()
        openList:remove(minFNote)
        closeList:add(minFNote)
        local aroundNotes = getNodeAround(minFNote)
        for k,arouNote in pairs(aroundNotes) do
            if openList:contains(arouNote) then
                if arouNote.g > minFNote.g+1 then
                    arouNote.father = minFNote
                    arouNote:setG(minFNote.g+1)
                end
            else
                arouNote:setF(minFNote.g+1, calcH(arouNote.x,arouNote.y,dx,dy))
                arouNote.father = minFNote
                openList:add(arouNote)
                if arouNote.x == dx and arouNote.y == dy then
                    local pathList = {}
                    local currNote = arouNote
                    while currNote do
                        table.insert(pathList, currNote)
                        currNote = currNote.father
                    end
                    -- 测试
                    print(closeList:isEmpty())
                    if closeList.close then
                        for k,node in pairs(closeList.close) do
                            local x,y = node.x,node.y
                            mapGird[x+y*girdX] = 3
                        end
                    end
                    --------
                    return pathList
                end
            end
        end
        if openList:isEmpty() then
            break
        end
    end
    return nil
end

function calcH(x,y,dx,dy)
    return 2*math.abs(x-dx)+math.abs(y-dy)
end

--检查格子是否符合条件
--忽略超出地图节点、障碍物节点、在closeList当中的节点
function checkNode(node)
    local x,y = node.x,node.y
    if x<0 or x>=girdX then
        return false
    elseif y<0 or y>=girdY then
        return false
    elseif mapGird[x+y*girdX]==1 then
        return false
    elseif closeList:contains(node) then
        return false
    end
    return true
end

--获取周围的格子
function getNodeAround(node)
    local x,y = node.x, node.y
    local nodeList = {
            PathNode:new(x, y-1),
            PathNode:new(x, y+1),
            PathNode:new(x-1, y),
            PathNode:new(x+1, y),
            }
    local newList = {}
    for k,v in pairs(nodeList) do
        if checkNode(v) then
            table.insert(newList, v)
        end
    end
    return newList
end

--打印地图
function printMap()
    for i=0,#mapGird do
        if mapGird[i]==0 then
            io.stdout:write(" - ")
        elseif mapGird[i]==1 then
            io.stdout:write(" # ")
        elseif mapGird[i]==2 then
            io.stdout:write(" * ")
        elseif mapGird[i]==3 then
            io.stdout:write(" ! ")
        end
        if (i+1)%8==0 then
            io.stdout:write("\n")
        end
    end
end

function drawPath(pathList)
    if pathList then
        for k,node in pairs(pathList) do
            local x,y = node.x,node.y
            mapGird[x+y*girdX] = 2
        end
    end
end
